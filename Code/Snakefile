configfile: "config.yaml"

wildcard_constraints:
    filename = ".+"  # Use 'filename' to represent the entire filename

with open(os.path.join(config["inputpath"], "file_list"), "r") as file:
    FULLSAMPLES = [line.strip().split(".")[0] for line in file]


SAMPLES = [sample.split("_R1_")[0] for sample in FULLSAMPLES]

leftEnding = "_R1_" + FULLSAMPLES[0].split("_R1_")[1]
rightEnding = leftEnding.replace("R1", "R2")

# print("sample name, left ending, right ending, respectively: ")
# print(SAMPLES[0])
# print(leftEnding)
# print(rightEnding)

rule all:
    input:
        expand(os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding,
                    "myTrinity_Origin_" + config["origin"] + "_Sample_{sample}" + leftEnding,
                    "formatted_myTrinity_Origin_" + config["origin"] + "_Sample_{sample}" + leftEnding + ".Trinity.fasta"),
                    sample=SAMPLES)

# Basic rule for testing environment. Should take all input files,
# and print them each to a file of the same base name.
rule testRuleAll:
    input:
        expand(os.path.join(config["outputpath"], "{sample}.txt"), sample=FULLSAMPLES)

rule testRuleHelper:
    params:
        "this file corresponds to {sample}"
    output:
        os.path.join(config["outputpath"], "{sample}.txt")
    shell:
        """
        echo {params} > {output}
       """

# run bowtie unmasked on samples
rule bowtieUnmasked:
    input:
        scriptPath=os.path.join(config["codepath"], "bowtieUnmaskedGenome.sh"),
        leftReadFile=os.path.join(config["inputpath"], "{sample}" + leftEnding +".fastq.gz"),
        rightReadFile=os.path.join(config["inputpath"], "{sample}" + rightEnding +".fastq.gz"),
        picard=config["picard"]
    params:
        outPath=config["outputpath"],
        codePath=config["codepath"],
        sampleNameLeft="{sample}" + leftEnding,
        sampleNameRight="{sample}" + rightEnding,
        bowtieERCCIndex=config["bowtieERCCIndex"],
        bowtieUnmaskedGenomeIndex=config["bowtieUnmaskedGenomeIndex"]
    output:
        ## following outputs are directly used by subsequent steps:
        os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding,
                    "Generated_Data_2nd_Bowtie_Alignment_Unmasked_Genome/unalignedRead1AgainstGenome_{sample}" + leftEnding + ".fq"),
        os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding,
                    "Generated_Data_2nd_Bowtie_Alignment_Unmasked_Genome/unalignedRead2AgainstGenome_{sample}" + rightEnding + ".fq"),
        ## following outputs are solely informational:
        # first bowtie alignment:
        os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding,
                    "ERCC_alignment_rates/ERCC_alignment_rate_{sample}"+ leftEnding +".txt"),
        # second bowtie alignment:
        os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding, 
                    "Generated_Data_2nd_Bowtie_Alignment_Unmasked_Genome/picard_stderr_{sample}"+ leftEnding +".txt"),
        os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding,
                    "Generated_Data_2nd_Bowtie_Alignment_Unmasked_Genome/picard_stdout_{sample}"+ leftEnding +".txt"),
        # post-processing
        os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding, "finished_bowtieUnmaskedGenome.txt")
    resources:
        cpus=12
    shell:
        """
        bash {input.scriptPath} {params.sampleNameLeft} {params.sampleNameRight} {input.leftReadFile} \
        {input.rightReadFile} {params.outPath} {params.codePath} {params.bowtieERCCIndex} \
        {params.bowtieUnmaskedGenomeIndex} {input.picard}
        """

rule starAfterBowtie:
    input:
        scriptPath=os.path.join(config["codepath"], "starAfterBowtie.sh"),
        leftUnaligned=os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding,
                    "Generated_Data_2nd_Bowtie_Alignment_Unmasked_Genome/unalignedRead1AgainstGenome_{sample}" + leftEnding + ".fq"),
        rightUnaligned=os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding,
                    "Generated_Data_2nd_Bowtie_Alignment_Unmasked_Genome/unalignedRead2AgainstGenome_{sample}" + rightEnding + ".fq"),
    params:
        sampleNameLeft="{sample}" + leftEnding,
        sampleNameRight="{sample}" + rightEnding,
        codePath=config["codepath"],
        outPath=os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding + "/"),
        hgStarDb=config["hg38_starDB"]
    output:
        ## following outputs are directly used by subsequent steps
        os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding,
                    "Generated_Data_Star_Alignment/{sample}" + leftEnding + "_unalignedRead1AgainstTranscriptome.fq"),
        os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding,
                    "Generated_Data_Star_Alignment/{sample}" + rightEnding + "_unalignedRead2AgainstTranscriptome.fq"),
        ## following outputs are solely informational
        os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding,
                    "Generated_Data_Star_Alignment/{sample}" + leftEnding + "_star_alignment_stats.txt")
    shell:
        """
        bash {input.scriptPath} {input.leftUnaligned} {input.rightUnaligned} \
        {params.sampleNameLeft} {params.sampleNameRight} {params.codePath} {params.outPath} {params.hgStarDb}
        """

rule bowtiePrimate:
    input:
        scriptPath=os.path.join(config["codepath"], "bowtiePrimate.sh"),
        leftUnaligned=os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding,
                    "Generated_Data_Star_Alignment/{sample}" + leftEnding + "_unalignedRead1AgainstTranscriptome.fq"),
        rightUnaligned=os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding,
                    "Generated_Data_Star_Alignment/{sample}" + rightEnding + "_unalignedRead2AgainstTranscriptome.fq"),
    params:
        outPath=os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding),
        codePath=config["codepath"],
        sampleNameLeft="{sample}" + leftEnding,
        sampleNameRight="{sample}" + rightEnding,
        primateIndex=config["bowtiePrimatePaths"]
    output:
        ## following outputs are directly used by subsequent steps
        os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding,
                    "primate_alignment_rates/unalignedRead1AgainstPrimate_{sample}" + leftEnding + ".fq"),
        os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding,
                    "primate_alignment_rates/unalignedRead1AgainstPrimate_{sample}" + rightEnding + ".fq")
        ## following outputs are solely informational
    shell:
        """
        bash {input.scriptPath} {input.leftUnaligned} {input.rightUnaligned} {params.outPath} \
        {params.codePath} {params.sampleNameLeft} {params.sampleNameRight} {params.primateIndex}
        """

## assembly remaining unaligned reads into contigs
rule trinity:
    input:
        scriptPath=os.path.join(config["codepath"], "all_trinity.sh"),
        leftUnaligned=os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding,
                    "primate_alignment_rates/unalignedRead1AgainstPrimate_{sample}" + leftEnding + ".fq"),
        rightUnaligned=os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding,
                    "primate_alignment_rates/unalignedRead1AgainstPrimate_{sample}" + rightEnding + ".fq")
    params:
        outPath=os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding),
        codePath=config["codepath"],
        sampleNameLeft="{sample}" + leftEnding,
        sampleNameRight="{sample}" + rightEnding,
        origin=config["origin"],
        minContigLen=config["minContigLen"]
    output:
        ## following outputs are directly used by subsequent steps
        os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding,
                    "myTrinity_Origin_" + config["origin"] + "_Sample_{sample}" + leftEnding,
                    "formatted_myTrinity_Origin_" + config["origin"] + "_Sample_{sample}" + leftEnding + ".Trinity.fasta")
        ## following outputs are solely informational
        os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding,
                    "myTrinity_Origin_" + config["origin"] + "_Sample_{sample}" + leftEnding,
                    "trinity_out_" + config["minContigLength"] + "_Sample_{sample}" + leftEnding + ".txt")
        os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding,
                    "myTrinity_Origin_" + config["origin"] + "_Sample_{sample}" + leftEnding,
                    "trinity_err_Sample_{sample}" + leftEnding + ".txt")
    shell:
        """
        bash {input.scriptPath} {input.leftUnaligned} {input.rightUnaligned} {params.sampleNameLeft} \
        {params.sampleNameRight} {params.origin} {params.minContigLen} {params.codePath} {params.outPath}
        """

## blast trinity assembled contigs for further host contamination
## TODO: in the original code, this script is run as a parallel array job
## on trinity output files split up in start_filter_host_kaiju.sh.
## First make it run sequentially on non-split trinity output, skipping start_filter_host_kaiju.sh.
rule filterHostKaiju:
    input:
        scriptPath=os.path.join(config["codepath"], "array_filter_host.sh"),
        program_RemoveHostForKaiju=config["program_RemoveHostForKaiju"],
        blastDB_Mammalia=config["blastDB_Mammalia"]
    params:
        sampleNameLeft="{sample}" + leftEnding,
        sampleNameRight="{sample}" + rightEnding,
        outPath=os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding),
        codePath=config["codepath"],
        origin=config["origin"]
    output:
    shell:
        """
        bash {input.scriptPath}
        """

# rule kaiju:
#     input:
#         scriptPath=os.path.join(config["codepath"], "protein_kaiju.sh"),
#         kaiju_nodes=config["kaiju_nodes"],
#         kaiju_fmi=config["kaiju_fmi"],
#         nonHostContigs= ##TODO fill in after determining output files of filterHostKaiju
#     params:
#         sampleNameLeft="{sample}" + leftEnding,
#         sampleNameRight="{sample}" + rightEnding,
#         outPath=os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding),
#         codePath=config["codepath"],
#         origin=config["origin"],
#         program_prodigal=config["program_prodigal"],
#         program_kaiju=config["program_kaiju"]
#     output:
#         os.path.join(config["outputpath"], "Sample_{sample}" + leftEnding, config["origin"] + "kaiju_output",
#                     "sorted_protein_kaiju_"+ config["origin"] + "_Sample_" + "{sample}" + leftEnding + ".tab")
#     shell:
#         """
#         bash {input.scriptPath} {params.sampleNameLeft} {params.sampleNameRight} {input.nonHostContigs} \
#         {params.origin} {params.program_prodigal} {params.program_kaiju} {input.kaiju_nodes} {input.kaiju_fmi} \
#         {params.codePath} {params.outPath}
#         """

## TODO: parse runs salmon, merge, and diversity for each taxonomic level output by kaiju.
## I need to think about the best way to convert this to rules, whether it is possible to have
## separate rules for each step and have snakemake manage the redundancies, or whether I should
## leave it as is for now except for converting to slurm syntax
# rule parseKaiju:

# rule merge:

# rule prepDiversity:

# rule salmon:

# rule palmScan: